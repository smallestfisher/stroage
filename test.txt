import socket
import struct
import threading
import time
from typing import Optional

try:
    from PIL import Image, ImageDraw  # 可选，用来生成测试图片
except ImportError:
    Image = None


SIGN = b"\x21\x2C\x37\x42"
HEAD_LEN = 9
HEAD_HEART = 0
HEAD_MINI_MAP = 1  # HUD 画面投屏
# HOST = "192.168.0.100"  # 或 192.168.0.16
HOST = "192.168.0.100"
PORT = 50050


def build_header(head_type: int, total_len: int) -> bytes:
    # total_len = HEAD_LEN + payload_len
    return SIGN + struct.pack("<B", head_type) + struct.pack("<I", total_len)


def build_mini_map_payload(png_bytes: bytes, width: int, height: int, pic_type: int = 2) -> bytes:
    # payload = picType(int) + width(int) + height(int) + len(int) + buf
    return (
        struct.pack("<I", pic_type)
        + struct.pack("<I", width)
        + struct.pack("<I", height)
        + struct.pack("<I", len(png_bytes))
        + png_bytes
    )


def build_mini_map_packet(png_bytes: bytes, width: int, height: int, pic_type: int = 2) -> bytes:
    payload = build_mini_map_payload(png_bytes, width, height, pic_type)
    total_len = HEAD_LEN + len(payload)
    header = build_header(HEAD_MINI_MAP, total_len)
    return header + payload


class HudTcpClient:
    def __init__(self, host: str, port: int):
        self.host = host
        self.port = port
        self.sock: Optional[socket.socket] = None
        self.running = False

    def connect(self, timeout=3.0) -> bool:
        if self.running:
            return True
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(timeout)
            s.connect((self.host, self.port))
            s.settimeout(None)
            self.sock = s
            self.running = True
            threading.Thread(target=self._heartbeat_loop, daemon=True).start()
            return True
        except Exception as e:
            print("connect fail:", e)
            self.close()
            return False

    def send(self, data: bytes):
        if not self.running or not self.sock:
            return
        try:
            self.sock.sendall(data)
        except Exception as e:
            print("send fail:", e)
            self.close()

    def _heartbeat_loop(self):
        """简单心跳：读取服务端心跳帧(headType=0)，再回一个空心跳头"""
        s = self.sock
        if not s:
            return
        try:
            while self.running:
                # 读签名
                sign = self._recv_exact(4)
                if sign != SIGN:
                    continue
                head_type = self._recv_exact(1)
                total_len_bytes = self._recv_exact(4)
                head_type_val = head_type[0]
                total_len = struct.unpack("<I", total_len_bytes)[0]
                payload_len = total_len - HEAD_LEN
                if payload_len > 0:
                    self._recv_exact(payload_len)  # 丢弃
                if head_type_val == HEAD_HEART:
                    # 回写心跳
                    self.send(build_header(HEAD_HEART, HEAD_LEN))
        except Exception as e:
            print("heartbeat loop end:", e)
        finally:
            self.close()

    def _recv_exact(self, n: int) -> bytes:
        s = self.sock
        if not s:
            raise ConnectionError("socket closed")
        buf = b""
        while len(buf) < n:
            chunk = s.recv(n - len(buf))
            if not chunk:
                raise ConnectionError("socket closed")
            buf += chunk
        return buf

    def close(self):
        self.running = False
        try:
            if self.sock:
                self.sock.close()
        finally:
            self.sock = None


def make_test_png(width=436, height=280) -> bytes:
    if Image is None:
        # 没装 Pillow 就发一个空 PNG（极简 1x1 红点）
        return b"\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x02\x00\x00\x00\x90wS\xde\x00\x00\x00\nIDATx\x9ccddbf\x00\x00\x00\x06\x00\x03\xe2!\xbc3\x00\x00\x00\x00IEND\xaeB`\x82"
    img = Image.new("RGB", (width, height), (30, 30, 30))
    draw = ImageDraw.Draw(img)
    draw.rectangle((20, 20, width - 20, height - 20), outline=(0, 200, 0), width=4)
    draw.text((30, 30), "HUD TEST", fill=(255, 255, 0))
    import io
    buf = io.BytesIO()
    img.save(buf, format="PNG")
    return buf.getvalue()


def main():
    client = HudTcpClient(HOST, PORT)
    if not client.connect():
        return
    png_bytes = make_test_png()
    packet = build_mini_map_packet(png_bytes, width=436, height=280, pic_type=2)
    # 连续发几帧测试
    for i in range(10):
        client.send(packet)
        time.sleep(0.1)
    time.sleep(1)
    client.close()


if __name__ == "__main__":
    main()